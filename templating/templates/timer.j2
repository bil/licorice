#define _GNU_SOURCE
#include <stdio.h>
#include <signal.h>
#include <sys/time.h>
#include <string.h>
#include <stdlib.h>
#include <sys/io.h>
#include <unistd.h>
#include <sched.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <fcntl.h>
#include <errno.h>
#include <stdbool.h>
#include <sys/types.h>
#include <stdint.h>
#include <semaphore.h>
#include <sys/wait.h>
#include <stdatomic.h>
#include <time.h>
#include "constants.h"
#include "utilityFunctions.h"

#define CHILD_HEIGHT {{topo_height}}
#define NUM_SOURCES {{source_names|length}}
#define NUM_SINKS {{sink_names|length}}
#define NSECS 600000

{% set test_start_time = (config['config'].has_key('test_start_time') and config['config']['test_start_time']) %}
{% set test_tick_time = (config['config'].has_key('test_tick_time') and config['config']['test_tick_time']) %}
// process IDs for each child numbered according to the index of the child's name
// in childProcNames
static pid_t ch_pids[NUM_CHILDREN];
{%- if child_names|length != 0 %}
static char childProcnames[NUM_CHILDREN][MAX_MODULE_NAME_LEN] = {{'{'}}{% for n in child_names[:-1] %}"{{n}}", {% endfor %}"{{child_names[-1]}}"{{'}'}};
{%- endif %}
static int childLens[CHILD_HEIGHT] = {{'{'}}{% for l in topo_lens[:-1] %}{{l}}, {% endfor %}{{topo_lens[-1]}}{{'}'}};
static int childTopoOrder[CHILD_HEIGHT][{{num_cores}}];
// network pid
static pid_t so_pids[NUM_SOURCES];
// logger pid
static pid_t si_pids[NUM_SINKS];
{% if parport_tick_addr -%}
static unsigned char outVal = 0;
{%- endif %}
// pointer to start of shared memory containing group timestamp and waveform data
static uint8_t *pmem;
static uint8_t *pFinish;
static uint32_t *pSignalMem;
static uint32_t *pCurSignalMem;
sigset_t exitMask;
static sigset_t alrmMask;
static unsigned long alrmNum = 0;
static uint32_t *pMSStart;
static uint32_t *pMSEnd;
static uint32_t *pDataStart;
static uint32_t *pDataEnd;
static sem_t *pSem;
static sem_t *pGlobalSems;
static sem_t *pSourceSemStart;

static int sigalrm_recv;
static int sigexit_recv;
static int sigchld_recv;

static int num_cores;
static int ex_i, al_i, de_i;

static struct itimerval rtTimer;
{%- if test_start_time %}
static struct timespec startTimer;
static time_t startStartSec;
static long startStartNSec;
{%- endif %}
{%- if test_tick_time %}
static struct timespec tickTimer;
static time_t tickStartSec;
static long tickStartNSec;
static unsigned long long tickTimeSum = 0;
static unsigned long numTicksMeasured = 0;
{%- endif %}

// INSERTED
static struct timespec record_timer;
static long curTime;
static time_t curSec;
static FILE *f;

void handle_exit(int exitStatus) {
{%- if test_tick_time %}
  printf("%llu time over %lu ticks\n", tickTimeSum, numTicksMeasured);
  printf("%f ns\n", ((float)tickTimeSum) / numTicksMeasured); 
{%- endif %}
  printf("exiting...\n");
  rtTimer.it_value.tv_sec = 0;
  rtTimer.it_value.tv_usec = 0;
  rtTimer.it_interval.tv_sec = 0;
  rtTimer.it_interval.tv_usec = 0;
  setitimer(ITIMER_REAL, &rtTimer, NULL);
  printf("Killing child processes...\n");
  // send SIGINT to all child processes and wait
  for (ex_i = 0; ex_i < NUM_CHILDREN; ex_i++) {
    printf("Killing child: %d\n", ch_pids[ex_i]);
    kill(ch_pids[ex_i], SIGINT);
    while (waitpid(ch_pids[ex_i], 0, WNOHANG) > 0);
  }
  // send SIGINT to logger process and wait
  for (ex_i = 0; ex_i < NUM_SINKS; ex_i++) {
    if (si_pids[ex_i] != -1) {
      kill(si_pids[ex_i], SIGINT);
      while (waitpid(si_pids[ex_i], 0, WNOHANG) > 0);
    }
  }
  // send SIGINT to network process and wait
  for (ex_i = 0; ex_i < NUM_SOURCES; ex_i++) {
    if (so_pids[ex_i] != -1) {
      kill(so_pids[ex_i], SIGINT);
      while (waitpid(so_pids[ex_i], 0, WNOHANG) > 0);
    }
  }
  printf("Unmapping shared memory...\n");
  printf("%lu SIGALRMs sent\n", alrmNum);
  // close shared memory
  munmap(pSignalMem, PAGESIZE);
  munmap(pmem, PAGESIZE);
  munmap(pGlobalSems, {{num_non_sources + num_sem_sigs}} * sizeof (sem_t));
  shm_unlink(SMEM0_PATHNAME);
  shm_unlink("/smem_sig_offsets");
  shm_unlink(SMEMSIG_PATHNAME);
  munlockall();
  exit(exitStatus);
}

void set_sched_prior(int priority) {
  struct sched_param param;
  param.sched_priority = priority;
  if (sched_setscheduler(0, SCHED_FIFO, &param) == -1) {
    die("sched_setscheduler failed.\n");
  }
}

static void check_children() {
{%- if test_tick_time %}
  clock_gettime(CLOCK_MONOTONIC_RAW, &tickTimer);
{% endif %}
  
  if (sigalrm_recv > 1)
    die("Timer missed a tick.");
{% if parport_tick_addr -%}
  // flip bits and output to parallel port
  outb(outVal,0x{{parport_tick_addr}});
  outVal = ~outVal;

  clock_gettime(CLOCK_MONOTONIC_RAW, &record_timer);
  curTime = record_timer.tv_nsec;
  curSec = record_timer.tv_sec;
  fprintf(f, "%ld %ld\n", curTime, curSec);
{%- endif %}

{%- if test_tick_time %}
  tickStartNSec = tickTimer.tv_nsec;
  tickStartSec = tickTimer.tv_sec;
{%- endif %}
  
  // increment SIGALRM counter
  alrmNum++;

  // only trigger network process on first iterations
  if (alrmNum <= LATENCY) {
    for (al_i = 0; al_i < NUM_SOURCES; al_i++) {
      kill(so_pids[al_i], SIGALRM);
    }
  }
  else { // normal behavior on subsequent iterations
    // check if children have finished execution in allotted time (could just check last round, but need to properly figure val topo stuff again)
    for (al_i = 0; al_i < childLens[CHILD_HEIGHT-1]; al_i++) {
      int chNum = childTopoOrder[CHILD_HEIGHT-1][al_i];
      if (pFinish[chNum]) {
        usleep(5000);
        printf("Violating child: %s, pFinish[%d]: %d\n", childProcnames[chNum], al_i, pFinish[al_i]);
        die("Child timing violation.\n");
      } 
      pFinish[chNum] = 0xff;
    }
    // check if sinks have finished execution in allotted time
    // if (pFinish[NUM_CHILDREN]) {
    //   printf("Logger timing violation on ms: %lu \n", alrmNum);
    //   //usleep(5000);
    //   //die("Logger timing violation.\n");
    // }
    pFinish[NUM_CHILDREN] = 0xff;

    // update ms start and end pointers for children
    //***** added recently, not tested yet ********
    //might need a lock around this with fence, since this should
    //look atomic to children. could use pthread reader writer locks
    atomic_thread_fence(memory_order_seq_cst);
    sem_wait(pSem);
    *pMSStart = *pMSEnd;
    *pMSEnd = *pDataEnd;
    // TODO make this generic for N signals

    pCurSignalMem = pSignalMem + 0;

    // NON-LATENCY-DEPENDENT UPDATE
    if (*(pCurSignalMem + 1) == *(pCurSignalMem + 3)) 
      *(pCurSignalMem + 0) = 0;
    else 
      *(pCurSignalMem + 0) = *(pCurSignalMem + 1);
    if (!*(pCurSignalMem + 2))
      *(pCurSignalMem + 1) = *(pCurSignalMem + 3);
    else 
      *(pCurSignalMem + 1) = *(pCurSignalMem + 2);

    // LATENCY-DEPENDENT UPDATE
    // if (*(pCurSignalMem + 0) == *(pCurSignalMem + 3)) 
    //   *(pCurSignalMem + 0) = 0;
    // else 
    //   *(pCurSignalMem + 0) += (32 * 2);
    // if (*(pCurSignalMem + 1) == *(pCurSignalMem + 3))
    //   *(pCurSignalMem + 1) = 32 * 2;
    // else 
    //   *(pCurSignalMem + 1) += (32 * 2);

    atomic_thread_fence(memory_order_release);
    sem_post(pSem);
    
    // trigger network process
    for (al_i = 0; al_i < NUM_SOURCES; al_i++) {
      kill(so_pids[al_i], SIGALRM);
    }

    // release global tick locks for all modules and sinks
    // TODO Might need to have lock here for network processes that have to do tick-level updates (like cerebus spike)
    for (al_i = 0; al_i < {{num_non_sources}}; al_i++) {
      sem_post(pGlobalSems + al_i);
    }
  }

{%- if test_tick_time %}
  clock_gettime(CLOCK_MONOTONIC_RAW, &tickTimer);
  numTicksMeasured++;
  tickTimeSum += ((tickTimer.tv_sec - tickStartSec) * 1000000000 + (tickTimer.tv_nsec - tickStartNSec));
  if (numTicksMeasured >= 1000 * 60 * 60) {
    handle_exit(0);
  }
{%- endif %}

  sigalrm_recv--;
}

// Handle SIGALRM on millisecond
void event_handler(int signum) {
  sigalrm_recv++;
}

void exit_handler(int signum) {
  sigexit_recv++;
}

void usr1_handler(int signum) {
  //do nothing, this sig is just used for communication
}

void usr2_handler(int signum) {
  //do nothing, this sig is just used for communication
}

void dead_child() {
  --sigchld_recv;
  int saved_errno = errno;
  int dead_pid;
  while ((dead_pid = waitpid((pid_t)(-1), 0, WNOHANG)) == 0);
  printf("dead pid: %d \n", dead_pid);
  for (de_i = 0; de_i < NUM_SINKS; de_i++) {   
    if (si_pids[de_i] == dead_pid) {
      si_pids[de_i] = -1;
    }
  }
  for (de_i = 0; de_i < NUM_SINKS; de_i++) {   
    if (so_pids[de_i] == dead_pid) {
      so_pids[de_i] = -1;
    }
  }
  for (de_i = 0; de_i < NUM_CHILDREN; de_i++) {
    if (ch_pids[de_i] == dead_pid) {
      ch_pids[de_i] = -1;
    }
  }
  errno = saved_errno;
  die("I have lost a child :( \n");
}

void chld_handler(int sig) {
  sigchld_recv++;
}

void stack_prefault() {
  unsigned char dummy[MAX_SAFE_STACK];
  memset(dummy, 0, MAX_SAFE_STACK);
}

int main(int argc, char* argv[]) {
{%- if test_start_time %}
  clock_gettime(CLOCK_MONOTONIC_RAW, &startTimer);
  startStartSec = startTimer.tv_sec;
  startStartNSec = startTimer.tv_nsec;
{% endif %}

  f = fopen("/home/a/output_filename","w");
  if (f == NULL) {
    printf("Error opening file!\n");
    handle_exit(1);
  }

  // set signal masks
  sigemptyset(&exitMask);
  sigaddset(&exitMask, SIGALRM);  
  sigfillset(&alrmMask);
  // sigdelset(&alrmMask, SIGINT);
  // initialize utilityFunctions
  init_utils(&handle_exit, &exitMask);

{%- if parport_tick_addr %}

  // make sure parport is writeable
  if (ioperm(0x{{parport_tick_addr}}, 1, 1)) {
    die("io permission denied\n");
  }
{%- endif %}

  // set signal handlers
  set_sighandler(SIGINT, &exit_handler, &exitMask);
  set_sighandler(SIGALRM, &event_handler, &alrmMask);
  set_sighandler(SIGUSR1, &usr1_handler, NULL);
  set_sighandler(SIGUSR2, &usr2_handler, NULL);
  set_sighandler(SIGCHLD, &chld_handler, NULL);
  printf("Handlers installed.\n");

  // create shared memory and map it
  printf("Mapping memory...\n");

  open_shared_mem((uint8_t **)&pSignalMem, "/smem_sig_offsets", PAGESIZE, O_TRUNC | O_CREAT | O_RDWR, PROT_READ | PROT_WRITE);
  pSourceSemStart = (sem_t *)(pSignalMem + {{num_internal_sigs}} * 4);

  open_shared_mem(&pmem, SMEM0_PATHNAME, PAGESIZE, O_TRUNC | O_CREAT | O_RDWR,  PROT_READ | PROT_WRITE);
  // set pmem header variables
  pSem = (sem_t*)pmem;
  pMSStart = (uint32_t*)pmem + SMEM0_MS_START_OFFSET;
  pMSEnd = (uint32_t*)pmem + SMEM0_MS_END_OFFSET;
  pDataStart = (uint32_t*)pmem + SMEM0_DATA_START_OFFSET;
  pDataEnd = (uint32_t*)pmem + SMEM0_DATA_END_OFFSET;
  pFinish = pmem + SMEM0_HEADER_LEN;
  open_shared_mem((uint8_t **)&pGlobalSems, SMEMSIG_PATHNAME, ({{num_non_sources + num_sem_sigs}}) * sizeof (sem_t), O_TRUNC | O_CREAT | O_RDWR,  PROT_READ | PROT_WRITE);


  // initialize non-source semaphores and signal semaphores
  int i;
  for (i = 0; i < {{num_non_sources + num_sem_sigs}}; i++) {
    sem_init(pGlobalSems + i, true, 0);
  }
  printf("Memory mapped.\nForking children...\n");
  // zero'd out byte in shared memory corresponding to child in child process

  //initialize semaphore
  sem_init(pSem, 1, 1);

  // get number of cores
  // Could also use _SC_NPROCESSORS_ONLN, but here we assume that all cores are online
  num_cores = sysconf(_SC_NPROCESSORS_CONF);
  
  // set priority
  set_sched_prior(PRIORITY);


{% for name in source_names -%} // TODO write this loop in C
  // fork and exec network process
  if ((so_pids[{{loop.index0}}] = fork()) == -1) {
    die("fork failed \n");
  }
  if (so_pids[{{loop.index0}}] == 0) { // only runs for network process
    cpu_set_t mask;
    CPU_ZERO(&mask);
    // for (int i = 2; i < num_cores - 1; i++) { // leave one core for system (core num_cores-1)
    //   CPU_SET(i, &mask);
    // }
    CPU_SET(NETWORK_CPU, &mask);
    sched_setaffinity(0, sizeof(cpu_set_t), &mask);
    setpriority(PRIO_PROCESS, 0, -19);
    set_sched_prior(PRIORITY);
    char* argv[2] = {"./{{name}}", NULL};
    
    // execute network process
    // signal handlers and mmap are not preserved on exec
    execvp(argv[0],argv);
    printf("network exec error. %s \n", strerror(errno));
    exit(1);
    //in case execvp fails
  }
  pause();
{%- endfor %}
  printf("Sources ready.\n");
{% for name in source_names -%}
  printf("{{name}}: %d\n", so_pids[{{loop.index0}}]);
{% endfor %}


{% if child_names|length != 0 -%}
  // fork and exec child processes
{% for i in range(0, topo_height) -%}
{% for j in range(0, topo_lens[i]) -%}
  childTopoOrder[{{i}}][{{j}}] = {{topo_order[i][j]}};
{%- endfor %}
{%- endfor %}
  
  for (i = 0; i < CHILD_HEIGHT; i++) {
    for (int j = 0; j < childLens[i]; j++) {
      int childNum = childTopoOrder[i][j];
      if (childNum == -1) { // source or sink
        continue;
      }
      if ((ch_pids[childNum] = fork()) == -1) {
        die("fork failed\n");
      }
      if (ch_pids[childNum] == 0) {  // only runs for child processes
        cpu_set_t mask;
        CPU_ZERO(&mask);
        CPU_SET(j + CPU_OFFSET, &mask);
        sched_setaffinity(0, sizeof(cpu_set_t), &mask);
        setpriority(PRIO_PROCESS, 0, -19);
        set_sched_prior(PRIORITY);
        char buf[4];
        char procBuf[64];
        sprintf(buf, "%d", childNum);
        printf("TEST HERE %s\n", childProcnames[childNum]);
        sprintf(procBuf, "./%s", childProcnames[childNum]);
        char* argv[3] = {procBuf, buf, NULL};
        
        // execute child process
        // signal handlers and mmap are not preserved on exec
        execvp(argv[0],argv);
        printf("child exec error. %s \n", strerror(errno));
        exit(1);
        //in case execvp fails
      }
      pause();
    }
  }
  printf("Internal modules ready.\n");
for (i = 0; i < CHILD_HEIGHT; i++) {
  printf("%s: %d\n", childProcnames[i], ch_pids[i]);
}
{%- endif %}

{% for name in sink_names -%}  // TODO write this loop in C
  // fork and exec data logger process
  if ((si_pids[{{loop.index0}}] = fork()) == -1) {
    die("fork failed \n");
  }
  if (si_pids[{{loop.index0}}] == 0) { // only runs for logger process
    cpu_set_t mask;
    CPU_ZERO(&mask);
    // for (int i = 1; i < num_cores - 1; i++) { // leave one core for system (core num_cores-1)
    //   CPU_SET(i, &mask);
    // }
    CPU_SET(LOGGER_CPU, &mask);
    sched_setaffinity(0, sizeof(cpu_set_t), &mask);
    setpriority(PRIO_PROCESS, 0, -19);
    set_sched_prior(PRIORITY);
    char* argv[2] = {"./{{name}}", NULL};
    
    // execute network process
    // signal handlers and mmap are not preserved on exec
    execvp(argv[0],argv);
    printf("logger exec error. %s \n", strerror(errno));
    exit(1);
    //in case execvp fails
  }
  pause();
{%- endfor %}
  printf("Sinks ready.\n");
{% for name in sink_names -%}
  printf("{{name}}: %d\n", si_pids[{{loop.index0}}]);
{% endfor %}
  make_realtime();

  for (i = 0; i < NUM_SOURCES; i++) {
    sem_post(pSourceSemStart + i); // start network immediately before setting timer
  }
  printf("Network process ready.\n");

{%- if test_start_time %}
  clock_gettime(CLOCK_MONOTONIC_RAW, &startTimer);
  printf("Start Time: %ld\n", (startTimer.tv_sec - startStartSec) * 1000000000 + startTimer.tv_nsec - startStartNSec);
  handle_exit(0);
{% endif %}

  // set up timer
  printf("Setting up timer...\n");

  rtTimer.it_value.tv_sec = SECREQ;
  rtTimer.it_value.tv_usec = USECREQ;
  rtTimer.it_interval.tv_sec = SECREQ;
  rtTimer.it_interval.tv_usec = USECREQ;
  setitimer(ITIMER_REAL, &rtTimer, NULL);

  while(1) {
    if (sigexit_recv)
      handle_exit(0);
    if (sigchld_recv)
      dead_child();
    if (sigalrm_recv > NSECS)
      handle_exit(0);
    if (sigalrm_recv)
      check_children();
    pause();
  }
}
