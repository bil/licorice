#define _GNU_SOURCE
#include <stdio.h>
#include <signal.h>
#include <sys/time.h>
#include <string.h>
#include <stdlib.h>
#include <sys/io.h>
#include <unistd.h>
#include <sched.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <fcntl.h>
#include <errno.h>
#include <stdbool.h>
#include <sys/types.h>
#include <stdint.h>
#include <semaphore.h>
#include <sys/wait.h>
#include <stdatomic.h>
#include "constants.h"
#include "utilityFunctions.h"

#define CHILD_HEIGHT {{topo_height}}
#define NUM_SOURCES {{source_names|length}}
#define NUM_SINKS {{sink_names|length}}

// process IDs for each child numbered according to the index of the child's name
// in childProcNames
static pid_t ch_pids[NUM_CHILDREN];
{%- if child_names|length != 0 %}
static char childProcnames[NUM_CHILDREN][MAX_MODULE_NAME_LEN] = {{'{'}}{% for n in child_names[:-1] %}"{{n}}", {% endfor %}"{{child_names[-1]}}"{{'}'}};
{%- endif %}
static int childLens[CHILD_HEIGHT] = {{'{'}}{% for l in topo_lens[:-1] %}{{l}}, {% endfor %}{{topo_lens[-1]}}{{'}'}};
static int childTopoOrder[CHILD_HEIGHT][{{num_cores}}];
// network pid
static pid_t so_pids[NUM_SOURCES];
// logger pid
static pid_t si_pids[NUM_SINKS];
{% if parport_tick_addr -%}
static unsigned char outVal = 0;
{%- endif %}
// pointer to start of shared memory containing group timestamp and waveform data
static uint8_t *pmem;
static uint8_t *pFinish;
static uint32_t *pSignalMem;
static uint32_t *pCurSignalMem;
sigset_t exitMask;
static sigset_t alrmMask;
static unsigned long alrmNum = 0;
static uint32_t *pMSStart;
static uint32_t *pMSEnd;
static uint32_t *pDataStart;
static uint32_t *pDataEnd;
static sem_t *pSem;
static sem_t *pSignalSems;

static int sigalrm_recv;
static int sigexit_recv;
static int sigchld_recv;

static int num_cores;
static int ex_i, al_i, de_i;

static struct itimerval timer;

void handle_exit(int exitStatus) {
  printf("exiting...\n");
  timer.it_value.tv_sec = 0;
  timer.it_value.tv_usec = 0;
  timer.it_interval.tv_sec = 0;
  timer.it_interval.tv_usec = 0;
  setitimer(ITIMER_REAL, &timer, NULL);
  printf("Killing child processes...\n");
  // send SIGINT to all child processes and wait
  for (ex_i = 0; ex_i < NUM_CHILDREN; ex_i++) {
    kill(ch_pids[ex_i], SIGINT);
    while (waitpid(ch_pids[ex_i], 0, WNOHANG) > 0);
  }
  // send SIGINT to logger process and wait
  for (ex_i = 0; ex_i < NUM_SINKS; ex_i++) {
    if (si_pids[ex_i] != -1) {
      kill(si_pids[ex_i], SIGINT);
      while (waitpid(si_pids[ex_i], 0, WNOHANG) > 0);
    }
  }
  // send SIGINT to network process and wait
  for (ex_i = 0; ex_i < NUM_SOURCES; ex_i++) {
    if (so_pids[ex_i] != -1) {
      kill(so_pids[ex_i], SIGINT);
      while (waitpid(so_pids[ex_i], 0, WNOHANG) > 0);
    }
  }
  printf("Unmapping shared memory...\n");
  printf("%lu SIGALRMs sent\n", alrmNum);
  // close shared memory
  munmap(pmem, PAGESIZE);
  munmap(pSignalSems, 1 + ({{num_sigs}} * sizeof (sem_t) - 1));
  shm_unlink(SMEM0_PATHNAME);
  munlockall();
  exit(exitStatus);
}

void set_sched_prior(int priority) {
  struct sched_param param;
  param.sched_priority = priority;
  if (sched_setscheduler(0, SCHED_FIFO, &param) == -1) {
    die("sched_setscheduler failed.\n");
  }
}

static void check_children() {
  // printf("ms start\n");
  if (sigalrm_recv > 1)
    die("Timer missed a tick.");
{% if parport_tick_addr -%}
  // flip bits and output to parallel port
  outVal = ~outVal;
  outb(outVal,0x{{parport_tick_addr}});
{%- endif %}

  // increment SIGALRM counter
  alrmNum++;

  // only trigger network process on first iterations
  if (alrmNum <= LATENCY) {
    for (al_i = 0; al_i < NUM_SOURCES; al_i++) {
      kill(so_pids[al_i], SIGALRM);
    }
  }
  else { // normal behavior on subsequent iterations
    // check if children have finished execution in allotted time (could just check last round, but need to properly figure val topo stuff again)
    for (al_i = 0; al_i < childLens[CHILD_HEIGHT-1]; al_i++) {
      int chNum = childTopoOrder[CHILD_HEIGHT-1][al_i];
      if (pFinish[chNum]) {
        usleep(5000);
        // printf("al_i:%d pFinish[%d]: %d\n", al_i, al_i, pFinish[al_i]);
        die("Child timing violation.\n");
      } 
      pFinish[chNum] = 0xff;
    }
    // check if logger has finished execution in allotted time
    if (pFinish[NUM_CHILDREN]) {
      printf("Logger timing violation on ms: %lu \n", alrmNum);
      //usleep(5000);
      //die("Logger timing violation.\n");
    }
    pFinish[NUM_CHILDREN] = 0xff;

    // update ms start and end pointers for children
    //***** added recently, not tested yet ********
    //might need a lock around this with fence, since this should
    //look atomic to children. could use pthread reader writer locks
    atomic_thread_fence(memory_order_seq_cst);
    *pMSStart = *pMSEnd;
    *pMSEnd = *pDataEnd;
    // TODO make this generic for N signals
    pCurSignalMem = pSignalMem + 0;
    *(pCurSignalMem + 0) = *(pCurSignalMem + 1);
    *(pCurSignalMem + 1) = *(pCurSignalMem + 2);
    atomic_thread_fence(memory_order_release);
    // trigger network process
    for (al_i = 0; al_i < NUM_SOURCES; al_i++) {
      kill(so_pids[al_i], SIGALRM);
    }

    // trigger first round of child processes. block if network is updating spike wave data
    sem_wait(pSem);
    for (al_i = 0; al_i < NUM_SINKS; al_i++) {
      kill(si_pids[al_i], SIGALRM);
    }
{%-for sem_pair in source_sems %}
  for (al_i = 0; al_i < {{sem_pair[1]}}; al_i++) {
    sem_post(&pSignalSems[{{sem_pair[0]}}]);
  }
{%-endfor%}
    sem_post(pSem);
  }
  sigalrm_recv--;
}

// Handle SIGALRM on millisecond
void event_handler(int signum) {
  sigalrm_recv++;
}

void exit_handler(int signum) {
  sigexit_recv++;
}

void usr1_handler(int signum) {
  //do nothing, this sig is just used for communication
}

void usr2_handler(int signum) {
  //do nothing, this sig is just used for communication
}

void dead_child() {
  --sigchld_recv;
  int saved_errno = errno;
  int dead_pid;
  while ((dead_pid = waitpid((pid_t)(-1), 0, WNOHANG)) == 0);
  printf("dead pid: %d \n", dead_pid);
  for (de_i = 0; de_i < NUM_SINKS; de_i++) {   
    if (si_pids[de_i] == dead_pid) {
      si_pids[de_i] = -1;
    }
  }
  for (de_i = 0; de_i < NUM_SINKS; de_i++) {   
    if (so_pids[de_i] == dead_pid) {
      so_pids[de_i] = -1;
    }
  }
  for (de_i = 0; de_i < NUM_CHILDREN; de_i++) {
    if (ch_pids[de_i] == dead_pid) {
      ch_pids[de_i] = -1;
    }
  }
  errno = saved_errno;
  die("I have lost a child :( \n");
}

void chld_handler(int sig) {
  sigchld_recv++;
}

void stack_prefault() {
  unsigned char dummy[MAX_SAFE_STACK];
  memset(dummy, 0, MAX_SAFE_STACK);
}

int main(int argc, char* argv[]) {
  // set signal masks
  sigemptyset(&exitMask);
  sigaddset(&exitMask, SIGALRM);  
  sigfillset(&alrmMask);
  // sigdelset(&alrmMask, SIGINT);
  // initialize utilityFunctions
  init_utils(&handle_exit, &exitMask);

{%- if parport_tick_addr %}

  // make sure parport is writeable
  if (ioperm(0x{{parport_tick_addr}}, 1, 1)) {
    die("io permission denied\n");
  }
{%- endif %}

  // set signal handlers
  set_sighandler(SIGINT, &exit_handler, &exitMask);
  set_sighandler(SIGALRM, &event_handler, &alrmMask);
  set_sighandler(SIGUSR1, &usr1_handler, NULL);
  set_sighandler(SIGUSR2, &usr2_handler, NULL);
  set_sighandler(SIGCHLD, &chld_handler, NULL);
  printf("Handlers installed.\n");

  // create shared memory and map it
  printf("Mapping memory...\n");

  open_shared_mem((uint8_t **)&pSignalMem, "/smem_sig_offsets", PAGESIZE, O_TRUNC | O_CREAT | O_RDWR, PROT_READ | PROT_WRITE);

  open_shared_mem(&pmem, SMEM0_PATHNAME, PAGESIZE, O_TRUNC | O_CREAT | O_RDWR,  PROT_READ | PROT_WRITE);
  // set pmem header variables
  pSem = (sem_t*)pmem;
  pMSStart = (uint32_t*)pmem + SMEM0_MS_START_OFFSET;
  pMSEnd = (uint32_t*)pmem + SMEM0_MS_END_OFFSET;
  pDataStart = (uint32_t*)pmem + SMEM0_DATA_START_OFFSET;
  pDataEnd = (uint32_t*)pmem + SMEM0_DATA_END_OFFSET;
  pFinish = pmem + SMEM0_HEADER_LEN;
  //Might need to change name of jinja variable
  open_shared_mem((uint8_t **)&pSignalSems, SMEMSIG_PATHNAME,
    1 + ({{num_sigs}} * sizeof (sem_t) - 1), O_TRUNC | O_CREAT | O_RDWR,  PROT_READ | PROT_WRITE);

  sem_t *curSem = pSignalSems;
  //initialize signal passing semaphores
  int i;
  for (i = 0; i < {{num_sigs}}; i++, curSem++) {
    sem_init(curSem, true, 0);
  }
  printf("Memory mapped.\nForking children...\n");
  // zero'd out byte in shared memory corresponding to child in child process

  //initialize semaphore
  sem_init(pSem, 1, 1);

  // get number of cores
  // Could also use _SC_NPROCESSORS_ONLN, but here we assume that all cores are online
  num_cores = sysconf(_SC_NPROCESSORS_CONF);
  
  // set priority
  set_sched_prior(PRIORITY);


{% for name in source_names -%} // TODO write this loop in C
  // fork and exec network process
  if ((so_pids[{{loop.index0}}] = fork()) == -1) {
    die("fork failed \n");
  }
  if (so_pids[{{loop.index0}}] == 0) { // only runs for network process
    cpu_set_t mask;
    CPU_ZERO(&mask);
    // for (int i = 2; i < num_cores - 1; i++) { // leave one core for system (core num_cores-1)
    //   CPU_SET(i, &mask);
    // }
    CPU_SET(NETWORK_CPU, &mask);
    sched_setaffinity(0, sizeof(cpu_set_t), &mask);
    setpriority(PRIO_PROCESS, 0, -19);
    set_sched_prior(PRIORITY);
    char* argv[2] = {"./{{name}}", NULL};
    
    // execute network process
    // signal handlers and mmap are not preserved on exec
    execvp(argv[0],argv);
    printf("network exec error. %s \n", strerror(errno));
    exit(1);
    //in case execvp fails
  }
  pause();
{%- endfor %}
  printf("Sources ready.\n");
  printf("source pid: %d\n", so_pids[0]);

{% if child_names|length != 0 -%}
  // fork and exec child processes
{% for i in range(0, topo_height) -%}
{% for j in range(0, topo_lens[i]) -%}
  childTopoOrder[{{i}}][{{j}}] = {{topo_order[i][j]}};
{%- endfor %}
{%- endfor %}
  
  for (i = 0; i < CHILD_HEIGHT; i++) {
    for (int j = 0; j < childLens[i]; j++) {
      int childNum = childTopoOrder[i][j];
      printf("%d\n", childNum);
      if ((ch_pids[childNum] = fork()) == -1) {
        die("fork failed\n");
      }
      if (ch_pids[childNum] == 0) {  // only runs for child processes
        cpu_set_t mask;
        CPU_ZERO(&mask);
        CPU_SET(j + CPU_OFFSET, &mask);
        sched_setaffinity(0, sizeof(cpu_set_t), &mask);
        setpriority(PRIO_PROCESS, 0, -19);
        set_sched_prior(PRIORITY);
        char buf[4];
        char procBuf[64];
        sprintf(buf, "%d", childNum);
        sprintf(procBuf, "./%s", childProcnames[childNum]);
        char* argv[3] = {procBuf, buf, NULL};
        
        // execute child process
        // signal handlers and mmap are not preserved on exec
        execvp(argv[0],argv);
        printf("child exec error. %s \n", strerror(errno));
        exit(1);
        //in case execvp fails
      }
      pause();
    }
  }
  printf("Internal modules ready.\n");
{%- endif %}

{% for name in sink_names -%}  // TODO write this loop in C
  // fork and exec data logger process
  if ((si_pids[{{loop.index0}}] = fork()) == -1) {
    die("fork failed \n");
  }
  if (si_pids[{{loop.index0}}] == 0) { // only runs for logger process
    cpu_set_t mask;
    CPU_ZERO(&mask);
    // for (int i = 1; i < num_cores - 1; i++) { // leave one core for system (core num_cores-1)
    //   CPU_SET(i, &mask);
    // }
    CPU_SET(LOGGER_CPU, &mask);
    sched_setaffinity(0, sizeof(cpu_set_t), &mask);
    setpriority(PRIO_PROCESS, 0, -19);
    set_sched_prior(PRIORITY);
    char* argv[2] = {"./{{name}}", NULL};
    
    // execute network process
    // signal handlers and mmap are not preserved on exec
    execvp(argv[0],argv);
    printf("logger exec error. %s \n", strerror(errno));
    exit(1);
    //in case execvp fails
  }
  pause();
{%- endfor %}
  printf("Sinks ready.\n");
  printf("sink pid: %d\n", si_pids[0]);

  make_realtime();

  for (i = 0; i < NUM_SOURCES; i++) { 
    kill(so_pids[i], SIGUSR2);
  }
  pause(); // TODO fix pause here to wait for all network processes
  printf("Network process ready.\n");
  // set up timer
  printf("Setting up timer...\n");
  timer.it_value.tv_sec = SECREQ;
  timer.it_value.tv_usec = USECREQ;
  timer.it_interval.tv_sec = SECREQ;
  timer.it_interval.tv_usec = USECREQ;
  //tell network to start gathering data.  First ms is therefore slightly longer than the rest.
  setitimer(ITIMER_REAL, &timer, NULL);
  while(1) {
    if (sigexit_recv)
      handle_exit(0);
    if (sigchld_recv)
      dead_child();
    if (sigalrm_recv)
      check_children();
    pause();
  }
}
