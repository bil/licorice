from libc.stdio cimport printf, stdout, fflush
from libc.stdlib cimport exit
from libc.stdint cimport int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t, int64_t, uint64_t
from libc.signal cimport SIGINT, SIGUSR1, SIGALRM, SIGBUS, SIGSEGV, SIGQUIT, SIGUSR2
from posix.signal cimport kill, sigaction, sigaction_t, sigset_t, sigemptyset, sigaddset, sigfillset, kill
from posix.unistd cimport getppid, pause, close, getpid
from posix.mman cimport shm_open, mmap, munmap, PROT_READ, PROT_WRITE, MAP_SHARED, mlockall, MCL_CURRENT, MCL_FUTURE, munlockall
from posix.fcntl cimport O_RDWR
from posix.types cimport pid_t
from libc.errno cimport errno, EINTR, EPIPE
from libc.string cimport memset
from posix.time cimport clock_gettime, CLOCK_MONOTONIC_RAW, timespec
from libcpp cimport bool
DEF SIG_BLOCK = 1

import pygame # TODO CHANGE LATER
import SharedArray as sa
import numpy as np
cimport numpy as np
cimport cython
import ctypes
import portio

{% set sig_type = out_signal['args']['type'] -%}
cdef extern from "utilityFunctions.h" nogil:
  enum: __GNU_SOURCE
  void die(char *errorStr)
  void open_shared_mem(uint8_t **ppmem, const char *pName, int numBytes, int shm_flags, int mmap_flags)
  void set_sighandler(int signum, void *psh, sigset_t *block_mask)
  void make_realtime()

cdef extern from "utilityFunctions.h":
  void init_utils(void (*pHandleExit)(int exitStatus), sigset_t *pExitMask)

{% if sig_type == 'parport' -%}
{% elif sig_type == 'udp' -%}
cdef extern from "<arpa/inet.h>":
  uint16_t htons(uint16_t hostshort)
  int inet_aton(const char *cp, in_addr *inp)

cdef extern from "<netinet/in.h>":
  enum: IPPROTO_UDP
  ctypedef uint16_t in_port_t
  ctypedef unsigned short sa_family_t
  struct in_addr:
    uint32_t s_addr
  struct sockaddr_in:
    sa_family_t sin_family
    in_port_t sin_port
    in_addr sin_addr
    unsigned char sin_zero[8]

cdef extern from "<sys/socket.h>":
  enum: AF_INET
  enum: SOCK_DGRAM
  ctypedef uint32_t socklen_t
  struct sockaddr:
    unsigned char sa_len
    unsigned char sa_family  
    char  sa_data[14]
  ssize_t recvfrom(int, void *restrict, size_t, int, sockaddr *restrict, socklen_t *restrict)
  int bind(int, const sockaddr *, socklen_t)
  int socket(int domain, int type, int protocol)
  ssize_t sendto(int socket, const void *message, size_t length,
       int flags, const sockaddr *dest_addr,
       socklen_t dest_len)
{%- elif sig_type == 'zmq' %}

cdef extern from "zmq.h":
  int zmq_close(void *s)
  int zmq_ctx_destroy(void *context)
  void *zmq_ctx_new()
  void *zmq_socket(void *, int type)
  int zmq_bind(void *s, const char *addr)
  int zmq_recv(void *s, void *buf, size_t len, int flags)
{%- elif sig_type == 'line' %}

cdef extern from "<alsa/asoundlib.h>" nogil:
  struct _snd_pcm:
    pass
  ctypedef _snd_pcm snd_pcm_t
  ctypedef unsigned long snd_pcm_uframes_t
  ctypedef long snd_pcm_sframes_t
  int snd_pcm_prepare(snd_pcm_t* pcm) 
  snd_pcm_sframes_t snd_pcm_writei(snd_pcm_t *pcm, const void *buffer, snd_pcm_uframes_t size) 

cdef extern from "lineUtilities.h":
  int pcm_init_play()
  void pcm_close_play()

cdef extern from "<sched.h>":
  enum: SCHED_FIFO
  ctypedef struct cpu_set_t:
    pass
  void CPU_ZERO(cpu_set_t *set)
  void CPU_SET(int cpu, cpu_set_t *set)

cdef extern from "<sys/types.h>":
  ctypedef unsigned int pthread_t
  ctypedef struct pthread_attr_t:
    pass
  ctypedef struct pthread_mutex_t:
    pass
  ctypedef struct pthread_cond_t:
    pass
  ctypedef struct pthread_mutexattr_t:
    pass
  ctypedef struct pthread_condattr_t:
    pass

cdef extern from "<pthread.h>" nogil:
  struct sched_param:
    int sched_priority
  int pthread_create(pthread_t *thread, pthread_attr_t *attr,
                          void *(*start_routine) (void *), void *arg)
  void pthread_exit(void *retval)
  int pthread_cond_signal(pthread_cond_t *cond)
  int pthread_mutex_lock(pthread_mutex_t *mutex)
  int pthread_mutex_unlock(pthread_mutex_t *mutex)
  int pthread_sigmask(int how, sigset_t *set, sigset_t *oldset)
  int pthread_join(pthread_t thread, void **retval)
  int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
  int pthread_setaffinity_np(pthread_t thread, size_t cpusetsize, cpu_set_t *cpuset)
  int pthread_setschedparam(pthread_t thread, int policy, sched_param *param)
  int pthread_mutex_init(pthread_mutex_t *mutex, pthread_mutexattr_t *attr)
  int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *attr)
  pthread_t pthread_self()
{%- endif %}

cdef extern from "semaphore.h":
  enum: __SIZEOF_SEM_T
  cdef union sem_union:
    char __size[__SIZEOF_SEM_T]
    long int __align
  ctypedef sem_union sem_t
  int sem_init(sem_t *, int, unsigned)
  int sem_wait(sem_t *)
  int sem_getvalue(sem_t *restrict, int *restrict)
  int sem_post(sem_t *)

cdef extern from "constants.h":
  enum: NUM_CHANNELS
  enum: MAX_PATH_LEN
  enum: NUM_CHILDREN
  enum: PAGESIZE
  enum: SMEM0_HEADER_LEN
  cdef const char *SMEM0_PATHNAME
  cdef const char *SMEMSIG_PATHNAME
  enum: NUM_NON_SOURCES
  enum: NUM_SEM_SIGS
  enum: NUM_INTERNAL_SIGS
  size_t ROUND_UP(int X, int Y)

#include <stdatomic.h>

cdef pid_t ppid
cdef sigset_t exitMask
cdef char pathName[MAX_PATH_LEN]

{% if sig_type == 'udp' -%}
cdef int s
cdef sockaddr_in si_other
cdef socklen_t slen=sizeof(si_other)
cdef socklen_t recv_len
{% elif sig_type == 'zmq' -%}
cdef void *radio
cdef void *context
{% elif sig_type == 'vis' -%}
# Init (CONSTRUCTOR)
cdef:
    int width = 600
    int height = 600
    tuple black = (0,0,0)

{%- elif sig_type == 'line' %}
cdef extern snd_pcm_t *play_handle
cdef snd_pcm_uframes_t frames
cdef int ret
cdef int rc
# threading variables
cdef pthread_t tid
cdef pthread_cond_t cv
cdef pthread_mutex_t mutex
cdef bool shouldDie = False
# worker thread vars
cdef char *zErrMsg
cdef void * retVal
cdef uint32_t lineWriteOffset = 0
cdef bool lineWrapped
{%- endif %}

cdef int sigalrm_recv = 0

cdef size_t shm_size
cdef uint8_t *pmem
cdef uint64_t *pNumTicks
cdef sem_t *pTickUpSems
cdef sem_t *pTickDownSems
cdef sem_t *pSigSems
cdef uint32_t *pBufVars
cdef uint32_t *pSelfBufVars
lastVal = 1

in_signals = {}
{%- if sig_types|length == 1 %}
{%- set sig = sig_types[0][0] %}
{%- endif %}
{%- for sig_type in sig_types %}
in_signals['{{sig_type[0]}}'] = None
cdef {{sig_type[1]}} *{{sig_type[0]}}StrtPtr
cdef {{sig_type[1]}} *{{sig_type[0]}}EndPtr
{% endfor %}

cdef {{out_dtype}} *outBuf
cdef size_t sentBytes
cdef size_t outBufLen

cdef void handle_exit(int exitStatus):
  global cv, mutex, retVal, tid, radio, context, s, shm_size, pmem
  {{destruct_code}}
{%- if sig_type == 'udp' %}
  close(s)
{%- elif sig_type == 'zmq' %}
  zmq_close(radio)
  zmq_ctx_destroy(context)
{%- elif sig_type == 'line' %}
  pthread_mutex_lock(&mutex)
  shouldDie = True
  pthread_cond_signal(&cv) 
  pthread_mutex_unlock(&mutex)
  pthread_join(tid, &retVal)
  pcm_close_play()
{%- endif %}
  munmap(pmem, shm_size)
  munlockall()
  exit(exitStatus)

cdef void exit_handler(int signum):
  handle_exit(0)

cdef void bus_handler(int signum):
  printf("Bus Error\n")
  handle_exit(1)

cdef void segv_handler(int signum):
  printf("Seg Fault\n")
  handle_exit(1)

cdef void usr2_handler(int signum):
  pass

{% if sig_type == 'line' -%}
cdef void* processRequests(void *arg) nogil:
  global mutex, cv, retVal, ret, frames, play_handle, pSelfBufVars, pSelfBufVars, zErrMsg, shouldDie, lineWriteOffset, {% for sig_type in sig_types %}{{sig_type[0]}}StrtPtr, {{sig_type[0]}}EndPtr{{"," if not loop.last}} {% endfor %}
  thread_sigmask(SIG_BLOCK, &exitMask, NULL)
  # int trc
  zErrMsg = <char *>0
  {%- if parser_buffers %}
  # TODO figure outBuf stuff for this
  # need to not use {{sig}} when there is a parser and instead do everything with outBuf, letting user set outBuf using {{sig}}StrtPtrs
  {%- endif %}
  while (True):
    pthread_mutex_lock(&mutex)
    pthread_cond_wait(&cv, &mutex) 

    if (shouldDie):
      retVal = NULL  
      pthread_exit(retVal)

    if (pSelfBufVars[1] < lineWriteOffset):
      lineWrapped = True

    while (lineWrapped or ((lineWriteOffset + frames * 2) < pSelfBufVars[1])):
      ret = snd_pcm_writei(play_handle, <void *>({{sig}}StrtPtr + lineWriteOffset), frames)
      if (ret == -EPIPE):
        # EPIPE means underrun
        printf("underrun occurred\n")
        snd_pcm_prepare(play_handle)
      elif (ret < 0):
       die("writei failed")
      elif (ret != <int>frames):
        die("short write")

      # z = 0
      # while (z < frames * 2):
      #   printf("%d ", (sigStrtPtr)[lineWriteOffset + z])
      #   z += 1
      # printf("\n\n")
      lineWriteOffset += (frames * 2)
      if (lineWriteOffset >= ({{sig}}EndPtr - {{sig}}StrtPtr)):
        lineWriteOffset = 0
        lineWrapped = False

    # why is this all the way down here?  won't the mutex be locked until it gets here (or its unlocking twice,
    # which isn't good either)? 
    pthread_mutex_unlock(&mutex)
{%- endif %}

# main
sigemptyset(&exitMask)
sigaddset(&exitMask, SIGALRM)
init_utils(&handle_exit, &exitMask)

ppid = getppid()

set_sighandler(SIGINT, &exit_handler, &exitMask)
set_sighandler(SIGBUS, &bus_handler, &exitMask)
set_sighandler(SIGSEGV, &segv_handler, &exitMask)
set_sighandler(SIGUSR2, &usr2_handler, NULL)

{% if sig_type == 'line' -%}
# init mutex and condition variable
rc = pthread_mutex_init(&mutex, NULL)
if (rc): die("pthread_mutex_init failed")
rc = pthread_cond_init(&cv, NULL)
if (rc): die("pthread_cond_init failed")
# create background thread
rc = pthread_create(&tid, NULL, &processRequests, NULL)
if (rc): die("pthread_create failed")

cdef sched_param param
param.sched_priority = 48
pthread_setschedparam(tid, SCHED_FIFO, &param)
cdef cpu_set_t mask
# cdef pthread_t maint = pthread_self()
# CPU_ZERO(&mask)
# CPU_SET(3, &mask)
# pthread_setaffinity_np(maint, sizeof(cpu_set_t), &mask)
CPU_ZERO(&mask)
CPU_SET(0, &mask)
pthread_setaffinity_np(tid, sizeof(cpu_set_t), &mask)
{%- endif %}

# open and map shared parent memory

shm_size = sizeof(uint64_t) + (sizeof(sem_t) * (1 + NUM_NON_SOURCES + NUM_SEM_SIGS)) + (sizeof(uint32_t) * 8 * NUM_INTERNAL_SIGS)
shm_size = ROUND_UP(shm_size, PAGESIZE)
open_shared_mem(&pmem, SMEM0_PATHNAME, shm_size, O_RDWR, PROT_READ | PROT_WRITE)
pNumTicks = <uint64_t *>(pmem)
pTickUpSems = <sem_t *>(pmem + sizeof(uint64_t) + sizeof(sem_t))
pTickDownSems = <sem_t *>(pmem + sizeof(uint64_t) + sizeof(sem_t) + (NUM_NON_SOURCES * sizeof(sem_t)))
pSigSems = <sem_t *>(pmem + sizeof(uint64_t) + sizeof(sem_t) + (2 * NUM_NON_SOURCES * sizeof(sem_t)))
pBufVars = <uint32_t *>(pmem + sizeof(uint64_t) + sizeof(sem_t) + (2 * NUM_NON_SOURCES * sizeof(sem_t)) + NUM_SEM_SIGS * sizeof(sem_t))

created_mem = sa.list()
{% for sig_type in sig_types %}
if any(['{{sig_type[0]}}' == x[0] for x in created_mem]):
  in_signals['{{sig_type[0]}}'] = sa.attach("shm://{{sig_type[0]}}") # TODO, fix dtype stuff  print 'tast '
  sa.mlock(in_signals['{{sig_type[0]}}'])
else:
  die("numpy signal not created\n")
# print in_signals
{{sig_type[0]}}StrtPtr = <{{sig_type[1]}} *><long>in_signals['{{sig_type[0]}}'].__array_interface__['data'][0] # TODO don't hardcode type
{{sig_type[0]}}EndPtr = {{sig_type[0]}}StrtPtr + len(in_signals['{{sig_type[0]}}'])
{% endfor %}

{% if parser_buffers -%}
# TODO malloc outBuf according to yaml config 
# set outBufLen accordingly
{%- endif %}

{% if sig_type == 'udp' -%}
# create a UDP socket
s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)
if (s == -1):
  die("NETWORK ERROR: socket\n")
# zero out the structure
memset(<char *> &si_other, 0, sizeof(si_other))
si_other.sin_family = AF_INET
si_other.sin_port = htons(51004)
if (inet_aton("{{out_signal['args']['addr']}}", &si_other.sin_addr)==0):
  die("inet_aton() failed\n")
{% elif sig_type == 'line' %}
# initiliaze line in 
frames = pcm_init_play()
print "FRAMES"
print frames
{% elif sig_type == 'parport' -%}
# make sure parport is writeable
if (portio.ioperm(0x{{out_signal['args']['addr']}}, 1, 1)):
  die("io permission denied\n")
{% elif sig_type == 'zmq' -%}
context = zmq_ctx_new() 
if (not context):
  die("Could not create ZMQ context.\n")
radio = zmq_socket(context, ZMQ_RADIO)
if (not radio):
  die("Could not create ZMQ socket.\n")
rc = zmq_connect(radio, "udp://192.168.1.1:5555")
assert (rc == 0)
{%- endif %}

{% if default_params -%}
{{default_sig_name}} = {{default_params}}
{%- endif %}

{{construct_code}}

make_realtime()

kill(ppid,SIGUSR1)
move_count = 0
while(True):
  sem_wait(&pTickUpSems[{{non_source_num}}])

{%- for dep_on in m_dep_on %}
  sem_wait(&pSigSems[{{dep_on[1]}}])
{%- endfor %}

  {{parser_code}} 

{%- if not parser_buffers %}
  pSelfBufVars = pBufVars + 8 * {{in_sig_nums[in_signals.keys()[0]]}}
  outBuf = {{sig}}StrtPtr + pSelfBufVars[0]
  outBufLen = pSelfBufVars[1] - pSelfBufVars[0] 
{%- endif %}
{%- if sig_type == 'udp' %}
  # debugging
  # printf("sink: %lu\n", outBufLen)
  for sentBytes in range(0,outBufLen,1472): # TODO read in MTU or make constant for user
    if (sendto(s, (<uint8_t *>outBuf) + sentBytes, 1472, 0, <sockaddr *>&si_other, slen)==-1):
      die("sendto() failed")
{%- elif sig_type == 'parport' %}
  portio.outb(<unsigned char>outBuf[0],0x{{out_signal['args']['addr']}})
{%- endif %}

{%- if sig_type == 'line' %}
  # Output handled in async thread

  if (pNumTicks[0] % 25 == 0):
    pthread_mutex_lock(&mutex)
    pthread_cond_signal(&cv)
    pthread_mutex_unlock(&mutex)
{%- endif %}

  sem_post(&pTickDownSems[{{non_source_num}}])
  sigalrm_recv -= 1