from libc.stdio cimport printf, stdout, fflush
from libc.stdlib cimport exit, malloc, free
from libc.stdint cimport int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t, int64_t, uint64_t
from libc.signal cimport SIGINT, SIGUSR1, SIGALRM, SIGBUS, SIGSEGV, SIGQUIT, SIGUSR2
from libc.string cimport memcpy
from posix.signal cimport kill, sigaction, sigaction_t, sigset_t, sigemptyset, sigaddset, sigfillset
from posix.unistd cimport getppid, pause, close, getpid
from posix.mman cimport shm_open, mmap, munmap, PROT_READ, PROT_WRITE, MAP_SHARED, mlockall, MCL_CURRENT, MCL_FUTURE, munlockall
from posix.types cimport pid_t
from libc.errno cimport errno, EINTR, EPIPE
from posix.fcntl cimport O_RDWR
from libc.string cimport memset
from posix.ioctl cimport ioctl
from posix.time cimport clock_gettime, CLOCK_MONOTONIC_RAW, timespec
from libcpp cimport bool

import sys
import SharedArray as sa
import numpy as np
cimport numpy as np
cimport cython
import portio

{% set test_throughput = (config['config'].has_key('test_throughput') and config['config']['test_throughput']) %}
{% set sig_type = in_signal['args']['type'] -%}
{% if sig_type == 'joystick' -%}
import pygame
{%- endif %}

cdef extern from "<sys/socket.h>":
  ctypedef uint32_t socklen_t

{% if sig_type == 'udp' -%}
cdef extern from "<arpa/inet.h>":
  uint16_t htons(uint16_t hostshort)

cdef extern from "<netinet/in.h>":
  enum: IPPROTO_UDP
  ctypedef uint16_t in_port_t
  ctypedef unsigned short sa_family_t
  struct in_addr:
    uint32_t s_addr
  struct sockaddr_in:
    sa_family_t sin_family
    in_port_t sin_port
    in_addr sin_addr
    unsigned char sin_zero[8]

cdef extern from "<sys/socket.h>":
  enum: AF_INET
  enum: SOCK_DGRAM
  struct sockaddr:
    unsigned char sa_len
    unsigned char sa_family  
    char  sa_data[14]
  ssize_t recvfrom(int, void *restrict, size_t, int, sockaddr *restrict, socklen_t *restrict)
  int bind(int, const sockaddr *, socklen_t)
  int socket(int domain, int type, int protocol)

cdef extern from "sourceUtils.h":
  in_addr get_ip (char* interface_name)
{% elif sig_type == 'zmq' -%}
cdef extern from "zmq.h":
  int zmq_close(void *s)
  int zmq_ctx_destroy(void *context)
  void *zmq_ctx_new()
  void *zmq_socket(void *, int type)
  int zmq_bind(void *s, const char *addr)
  int zmq_recv(void *s, void *buf, size_t len, int flags)
{% elif sig_type == 'line' %}
cdef extern from "<alsa/asoundlib.h>":
  struct _snd_pcm:
    pass
  ctypedef _snd_pcm snd_pcm_t
  ctypedef unsigned long snd_pcm_uframes_t
  ctypedef long snd_pcm_sframes_t
  int snd_pcm_prepare(snd_pcm_t* pcm) 
  snd_pcm_sframes_t snd_pcm_readi (snd_pcm_t *pcm, void *buffer, snd_pcm_uframes_t size)  

cdef extern from "lineUtilities.h":
  int pcm_init_cap()
  void pcm_close_cap()
{% endif %}

cdef extern from "semaphore.h":
  enum: __SIZEOF_SEM_T
  cdef union sem_union:
    char __size[__SIZEOF_SEM_T]
    long int __align
  ctypedef sem_union sem_t
  int sem_init(sem_t *, int, unsigned)
  int sem_wait(sem_t *)
  int sem_getvalue(sem_t *restrict, int *restrict)
  int sem_post(sem_t *)

cdef extern from "utilityFunctions.h":
  void init_utils(void (*pHandleExit)(int exitStatus), sigset_t *pExitMask)
  void die(char *errorStr)
  void open_shared_mem(uint8_t **ppmem, const char *pName, int numBytes, int shm_flags, int mmap_flags)
  void set_sighandler(int signum, void *psh, sigset_t *block_mask)
  void make_realtime()

cdef extern from "constants.h":
  enum: NUM_CHANNELSf
  enum: MAX_PATH_LEN
  enum: PAGESIZE
  enum: INIT_BUFFER_TICKS
  enum: BYTES_PER_FRAME
  const char *SMEM0_PATHNAME
  enum: NUM_NON_SOURCES
  enum: NUM_SEM_SIGS
  enum: NUM_INTERNAL_SIGS
  size_t ROUND_UP(int X, int Y)

#include <stdatomic.h>

cdef pid_t ppid
cdef sigset_t exitMask
cdef char pathName[MAX_PATH_LEN]
cdef socklen_t recvLen
{% if in_signal['args']['parser'] -%}
cdef char buf[{{in_signal['schema']['data']['shape']}}]
{%- endif %}
cdef char *outbuf
cdef int parse_idx
cdef uint32_t out_sig_shape
{%- if sig_type == 'zmq' %}
cdef int num_packets = 0
cdef void *dish
cdef void *context
{%- elif sig_type == 'udp' %}
cdef int num_packets = 0
cdef int s
cdef sockaddr_in si_me, si_other
cdef socklen_t slen = sizeof(si_other) 
cdef in_addr interface_ip
{%- elif sig_type == 'line' %}
cdef extern snd_pcm_t *cap_handle
cdef snd_pcm_uframes_t frames
cdef int ret
{%- elif sig_type == 'parport' %}
cdef unsigned char inVal
readInput = False
recvLen = 1
{%- elif sig_type == 'joystick' %}
recvLen = 2
readInput = False
{%- endif %}
parentSetup = True

cdef size_t shm_size
cdef uint8_t *pmem
cdef uint64_t *pNumTicks
cdef sem_t *pSourceSem
cdef uint32_t *pBufVars
# 0: ms start
# 1: ms end
# 2: next data location
# 3: num samples received this ms
# 4: buffer end offset (samples)
# 5: packet size (bytes)
# 6: max samples per tick (samples)
# 7: buffer size offset (samples)
cdef unsigned long packetNum = 0
cdef unsigned long numDropped = 0
cdef int i

out_sigs = {}
{%- if not parser %}
out_sig = None
{%- endif %}
cdef in_bytes = {{in_signal['schema']['data']['shape']}} * sizeof({{in_dtype}})
cdef {{in_dtype}} *bufStrtPtr
cdef {{in_dtype}} *bufEndPtr
cdef {{in_dtype}} *bufCurPtr
{%- for sig, dtype in sig_types.iteritems() %}
cdef {{dtype}} *{{sig}}StrtPtr
cdef uint32_t *{{sig}}BufVars
{%- endfor %}

cdef void handle_exit(int exitStatus):
  global pmem, shm_size, num_packets, pNumTicks, numDropped
  {{destruct_code}}
  created_mem = sa.list()
{%- for sig,args in out_signals.iteritems() %}
  if any(['{{sig}}' == x[0] for x in created_mem]):
    sa.delete("shm://{{sig}}")
{%- endfor %}
{%- if sig_type == 'udp' %}
  if (s):
    close(s)
{%- elif sig_type == 'zmq' %}
  zmq_close(dish)
  zmq_ctx_destroy(context)
{%- elif sig_type == 'line' %}
  pcm_close_cap()
{%- endif %}
{%- if sig_type == 'udp' or sig_type == 'zmq' %}
  printf("Received %d packets over %ld ms. Dropped %lu\n", num_packets, pNumTicks[0], numDropped)
{%- endif %}
{%- if parser %}
  free(bufStrtPtr)
{%- endif %}
  munmap(pmem, shm_size)
  munlockall()
  exit(exitStatus)

cdef void exit_handler(int signum):
  handle_exit(0)

cdef void bus_handler(int signum):
  printf("Bus Error\n")
  handle_exit(1)

cdef void segv_handler(int signum):
  printf("Seg Fault\n")
  handle_exit(1)

cdef void alrm_handler(int signum):
  global parentSetup, readInput
  if (parentSetup):
    parentSetup = False
{%- if sig_type == 'parport' or sig_type == 'joystick' %}
  global readInput
  readInput = True
{%- endif %}

cdef void usr2_handler(int signum):
  pass

# main
sigfillset(&exitMask)
init_utils(&handle_exit, &exitMask)

cdef int pid = getpid()
ppid = getppid()

set_sighandler(SIGALRM, &alrm_handler, NULL)
set_sighandler(SIGINT, &exit_handler, &exitMask)
set_sighandler(SIGBUS, &bus_handler, &exitMask)
set_sighandler(SIGSEGV, &segv_handler, &exitMask)
set_sighandler(SIGUSR2, &usr2_handler, NULL)

shm_size = sizeof(uint64_t) + (sizeof(sem_t) * (1 + NUM_NON_SOURCES + NUM_SEM_SIGS)) + (sizeof(uint32_t) * 8 * NUM_INTERNAL_SIGS)
shm_size = ROUND_UP(shm_size, PAGESIZE)
open_shared_mem(&pmem, SMEM0_PATHNAME, shm_size, O_RDWR, PROT_READ | PROT_WRITE)
pNumTicks = <uint64_t *>(pmem)
pSourceSem = <sem_t *>(pmem + sizeof(uint64_t))
pBufVars = <uint32_t *>(pmem + sizeof(uint64_t) + sizeof(sem_t) + (2 * NUM_NON_SOURCES * sizeof(sem_t)) + NUM_SEM_SIGS * sizeof(sem_t))

{% if sig_type == 'udp' -%}
# create a UDP socket
s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)
if (s == -1):
  die("NETWORK ERROR: socket\n")
# zero out the structure
memset(<char *> &si_me, 0, sizeof(si_me))
si_me.sin_family = AF_INET
si_me.sin_port = htons({{in_signal['args']['port']}})
interface_ip = get_ip("{{in_signal['args']['interface']}}")
si_me.sin_addr.s_addr = interface_ip.s_addr
# bind socket to port
if(bind(s, <sockaddr *>&si_me, sizeof(si_me))  == -1):
  print errno
  die("bind\n")
{% elif sig_type == 'line' %}
# initiliaze line in 
frames = pcm_init_cap()
recvLen = frames * BYTES_PER_FRAME / 2
{% elif sig_type == 'parport' -%}
# make sure parport is writeable
if (portio.ioperm(0x{{in_signal['args']['addr']}}, 1, 1)):
  die("io permission denied\n")
{% elif sig_type == 'zmq' -%}
context = zmq_ctx_new()
if (not context):
  die("Could not create ZMQ context.\n")
dish = zmq_socket(context, ZMQ_DISH)
if (not dish):
  die("Could not create ZMQ socket.\n")
rc = zmq_bind(dish, "udp://{{in_signal['args']['addr']}}:{{in_signal['args']['port']}}")
assert (rc == 0)
# {% elif sig_type == 'joystick' -%}
# pygame.init()
# pygame.joystick.init()

# if pygame.joystick.get_count() < 1:
#   die("No joystick detected.\n")

# joystick = pygame.joystick.Joystick(0)
# joystick.init()
{%- endif %}

created_mem = sa.list()
{% for sig,args in out_signals.iteritems() %}
if any(['{{sig}}' == x[0] for x in created_mem]):
  sa.delete("shm://{{sig}}")
  die("numpy signal already created\n")
else:
  {%- if sig_type == 'line' %}
  out_sig_shape = {{args['history']}} * frames
  dtype = np.int16 # TODO grab this from alsa
  {% else %}
  out_sig_shape = {{args['shape']}} * {{args['history']}}
  dtype = np.{{args['dtype']}}
  {% endif %}
  out_sigs['{{sig}}'] = sa.create("shm://{{sig}}", out_sig_shape, dtype=dtype)
  {%- if not parser %}
  out_sig = out_sigs['{{sig}}']
  {%- endif %}
  sa.mlock(out_sigs['{{sig}}'])
  {{sig}}BufVars = pBufVars + ({{out_sig_nums[sig] * 8}})
  {{sig}}BufVars[7] = out_sig_shape
    {%- if sig_type == 'line' %}
  {{sig}}BufVars[6] = recvLen
  {{sig}}BufVars[5] = frames # TODO, this right? should be packet size in bytes
  {{sig}}BufVars[3] = out_sig_shape
  {{sig}}BufVars[0] = {{sig}}BufVars[3]
    {%- else %}
  {{sig}}BufVars[6] = {{args['shape']}} 
  {{sig}}BufVars[5] = {{in_signal['schema']['data']['shape']}}  #* sizeof({{sig_types[sig]}}) # TODO for multiple outputs, user will have to specify packet size per signal (distribution of bytes across signals)
    {%- endif %}
{%- endfor %}
{%- if parser %}
bufStrtPtr = <{{in_dtype}} *>malloc(in_bytes)
bufCurPtr = bufStrtPtr
bufEndPtr = bufStrtPtr + {{in_signal['schema']['data']['shape']}}
{%- else %}
bufStrtPtr = <{{in_dtype}} *><long>out_sig.__array_interface__['data'][0]
bufCurPtr = bufStrtPtr
bufEndPtr = bufStrtPtr + out_sig_shape # this must be 1D for no parser
{%- endif %}

{% if default_params -%}
{{in_sig_name}} = {{default_params}}
{%- endif %}
{{construct_code}}

make_realtime()

fflush(stdout)
kill(ppid, SIGUSR2) # this source is initialized

pause()

while(True):
{%- if sig_type == 'udp' %}
  recvLen = recvfrom(s, bufCurPtr, in_bytes, 0, <sockaddr *> &si_other, &slen)
  if (recvLen == -1 and errno != EINTR):
    die("NETWORK ERROR: recvfrom()\n")
  if (recvLen == -1):
    die("Read error.\n")
  tmp = ((<unsigned long *>bufCurPtr)[0]) - packetNum
  {%- if test_throughput %}
  if (not parentSetup):
    if (packetNum and (tmp != 1)):
      printf("dropped %lu packets\n", <unsigned long>tmp)
      printf("%lu\n", packetNum)
      printf("%lu\n", (<unsigned long *>bufCurPtr)[0])
      numDropped += <unsigned long>tmp
    packetNum = (<unsigned long *>bufCurPtr)[0]
    num_packets += 1
  {%- endif %}
{% elif sig_type == 'line' %}
  #read from line in
  ret = snd_pcm_readi(cap_handle, <char *>bufCurPtr, frames)
  for i in range(640):
    pass
    # printf("%u\n", bufCurPtr[i])
  if (ret == -EPIPE):
    # EPIPE means overrun
    die("pcm overrun")
    snd_pcm_prepare(cap_handle)
  elif (ret < 0):
    die("pcm read error")
  elif (ret != <int>frames):
    die("pcm short error")
{%- elif sig_type == 'parport' %}
  # recvLen always 1 for parport
  if (readInput):
    readInput = False
    inVal = <unsigned char>portio.inb(0x{{in_signal['args']['addr']}})
    bufCurPtr[0] = inVal
  else:
    pause()
    continue
{%- elif sig_type == 'zmq' %}
  recvLen = zmq_recv(dish, bufCurPtr, in_bytes, 0)
  if (recvLen == -1):
    die("zmq_recv error.\n")
  num_packets += 1
{%- elif sig_type == 'joystick' %}
  if (readInput):
    readInput = False
    pygame.event.pump()
    for axis in range(recvLen):
      bufCurPtr[axis] = joystick.get_axis(axis)
  else:
    pause()
    continue
{%- else %}
  pause()
{%- endif %}

  if (parentSetup):
    continue

{%- if parser %}
  # use user parser
  {{parser_code}}
{%- endif %}
  # TODO figure out how to step through data for something like line (artificial data packaging per tick)
  # TODO figure out buffer updates for multiple output signals
  sem_wait(pSourceSem)
{%- for sig, args in out_signals.iteritems() %}

  # debugging
  # printf("source 1 : %u %u %u %u %u %u %u %u  \n", {{sig}}BufVars[0], {{sig}}BufVars[1], {{sig}}BufVars[2], {{sig}}BufVars[3], {{sig}}BufVars[4], {{sig}}BufVars[5], {{sig}}BufVars[6], {{sig}}BufVars[7])
  {{sig}}BufVars[2] += {{sig}}BufVars[5]
  {{sig}}BufVars[3] += {{sig}}BufVars[5]
  if ({{sig}}BufVars[7] - {{sig}}BufVars[1] <= {{sig}}BufVars[6]):
    {{sig}}BufVars[4] = {{sig}}BufVars[2]
  else:
    {{sig}}BufVars[4] = {{sig}}BufVars[2] if ({{sig}}BufVars[2] > {{sig}}BufVars[4]) else {{sig}}BufVars[4]
  {{sig}}BufVars[2] %= {{sig}}BufVars[7]
  bufCurPtr = bufStrtPtr + {{sig}}BufVars[2]
  # debugging
  # printf("source 2: %u %u %u %u %u %u %u %u  \n", {{sig}}BufVars[0], {{sig}}BufVars[1], {{sig}}BufVars[2], {{sig}}BufVars[3], {{sig}}BufVars[4], {{sig}}BufVars[5], {{sig}}BufVars[6], {{sig}}BufVars[7])
{%- endfor %}

  sem_post(pSourceSem)

