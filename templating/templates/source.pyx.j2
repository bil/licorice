from libc.stdio cimport printf, stdout, fflush
from libc.stdlib cimport exit
from libc.stdint cimport uint8_t, uint16_t, uint32_t, int64_t
from libc.signal cimport SIGINT, SIGUSR1, SIGALRM, SIGBUS, SIGSEGV, SIGQUIT, SIGUSR2
from posix.signal cimport kill, sigaction, sigaction_t, sigset_t, sigemptyset, sigaddset, sigfillset
from posix.unistd cimport getppid, pause, close, getpid
from posix.mman cimport shm_open, mmap, munmap, PROT_READ, PROT_WRITE, MAP_SHARED, mlockall, MCL_CURRENT, MCL_FUTURE, munlockall
from posix.types cimport pid_t
from libc.errno cimport errno, EINTR
from posix.fcntl cimport O_RDWR
from libc.string cimport memset
from posix.ioctl cimport ioctl

import SharedArray as sa
import numpy as np
cimport numpy as np
cimport cython
import portio
{% if in_signal['args']['parser'] -%}
import {{parser}}
{%- endif %}

{% set sig_type = in_signal['args']['type'] -%}
{% if sig_type == 'parport' -%}
{% elif sig_type == 'udp' -%}
cdef extern from "<arpa/inet.h>":
  uint16_t htons(uint16_t hostshort)

cdef extern from "<netinet/in.h>":
  enum: IPPROTO_UDP
  ctypedef uint16_t in_port_t
  ctypedef unsigned short sa_family_t
  struct in_addr:
    uint32_t s_addr
  struct sockaddr_in:
    sa_family_t sin_family
    in_port_t sin_port
    in_addr sin_addr
    unsigned char sin_zero[8]

cdef extern from "<sys/socket.h>":
  enum: AF_INET
  enum: SOCK_DGRAM
  ctypedef uint32_t socklen_t
  struct sockaddr:
    unsigned char sa_len
    unsigned char sa_family  
    char  sa_data[14]
  ssize_t recvfrom(int, void *restrict, size_t, int, sockaddr *restrict, socklen_t *restrict)
  int bind(int, const sockaddr *, socklen_t)
  int socket(int domain, int type, int protocol)

cdef extern from "sourceUtils.h":
  in_addr get_ip (char* interface_name);
{% elif sig_type == 'zmq' -%}
cdef extern from "zmq.h":
  int zmq_close(void *s)
  int zmq_ctx_destroy(void *context)
  void *zmq_ctx_new()
  void *zmq_socket(void *, int type)
  int zmq_bind(void *s, const char *addr)
  int zmq_recv(void *s, void *buf, size_t len, int flags)
{% endif %}

cdef extern from "utilityFunctions.h":
  void init_utils(void (*pHandleExit)(int exitStatus), sigset_t *pExitMask)
  void die(char *errorStr)
  void open_shared_mem(uint8_t **ppmem, const char *pName, int numBytes, int shm_flags, int mmap_flags)
  void set_sighandler(int signum, void *psh, sigset_t *block_mask)
  void make_realtime()

cdef extern from "constants.h":
  enum: NUM_CHANNELSf
  enum: MAX_PATH_LEN
  enum: PAGESIZE
  enum: LATENCY

#include <stdatomic.h>

cdef pid_t ppid
cdef sigset_t exitMask
cdef char pathName[MAX_PATH_LEN]
{% if in_signal['args']['parser'] -%}
cdef char buf[{{max_buf_size}}]
{%- endif %}
cdef char *outbuf
cdef int buf_offset = 0
cdef int parse_idx
cdef int out_sig_size
{%- if sig_type == 'udp' or sig_type == 'zmq' %}
cdef int num_packets = 0
{%- endif %}
cdef int64_t numMS= -1 * LATENCY
parentSetup = True

{% if sig_type == 'udp' -%}
cdef int s
cdef sockaddr_in si_me, si_other
cdef socklen_t slen = sizeof(si_other) 
cdef in_addr interface_ip
cdef socklen_t recv_len
{% elif sig_type == 'zmq' -%}
cdef void *dish
cdef void *context
cdef socklen_t recv_len
{%- endif %}

cdef uint32_t *pSignalMem
cdef uint32_t *pLocalSignalMem

{% if in_signal['args']['parser'] -%}
out_sigs = []
{% else -%}
cdef uint32_t *sigPtr
{%- endif %}

cdef void handle_exit(int exitStatus):
{%- for sig,args in out_signals.iteritems() %}
  sa.delete("shm://{{sig}}")
{%- endfor %}
{%- if sig_type == 'udp' %}
  close(s)
{%- elif sig_type == 'zmq'%}
  zmq_close(dish)
  zmq_ctx_destroy(context)
{%- endif %}
{%- if sig_type == 'udp' or sig_type == 'zmq' %}
  printf("Received %d packets over %ld ms.\n", num_packets, numMS)
{%- endif %}
  exit(exitStatus)

cdef void exit_handler(int signum):
  handle_exit(0)

cdef void bus_handler(int signum):
  printf("Bus Error\n")
  handle_exit(1)

cdef void segv_handler(int signum):
  printf("Seg Fault\n")
  handle_exit(1)

cdef void alrm_handler(int signum):
  global numMS, parentSetup
  if (parentSetup):
    parentSetup = False
  numMS += 1

cdef void usr2_handler(int signum):
  pass

# main
sigfillset(&exitMask)
init_utils(&handle_exit, &exitMask)

ppid = getppid()

set_sighandler(SIGALRM, &alrm_handler, NULL)
set_sighandler(SIGINT, &exit_handler, &exitMask)
set_sighandler(SIGBUS, &bus_handler, &exitMask)
set_sighandler(SIGSEGV, &segv_handler, &exitMask)
set_sighandler(SIGUSR2, &usr2_handler, NULL)

open_shared_mem(<uint8_t **>&pSignalMem, "/smem_sig_offsets", PAGESIZE, O_RDWR,  PROT_READ | PROT_WRITE)
pLocalSignalMem = pSignalMem + 0 # TODO number all internal signals for use by corresponding source/module

created_mem = sa.list()
{% for sig,args in out_signals.iteritems() %}
if any(['{{sig}}' == x[0] for x in created_mem]):
  sa.delete("shm://{{sig}}")
  die("numpy signal already created\n")
else:
  out_sig_size = {{args['shape']}} * {{args['history']}}
{% if in_signal['args']['parser'] -%}
  out_sigs.append = [sa.create("shm://{{sig}}", out_sig_size, dtype=np.{{args['dtype']}}), out_sig_size] # TODO, fix dtype stuff
  sa.mlock(out_sig)
{% else -%}
  sigPtr = <uint32_t *><long>sa.create("shm://{{sig}}", out_sig_size, dtype=np.{{args['dtype']}}).__array_interface__['data'][0] # TODO don't hardcode type
{% endif %}
{% endfor %}

{% if sig_type == 'udp' -%}
# create a UDP socket
s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)
if (s == -1):
  die("NETWORK ERROR: socket\n")
# zero out the structure
memset(<char *> &si_me, 0, sizeof(si_me))
si_me.sin_family = AF_INET
si_me.sin_port = htons({{in_signal['args']['port']}})
interface_ip = get_ip("{{in_signal['args']['interface']}}")
si_me.sin_addr.s_addr = interface_ip.s_addr
# bind socket to port
if(bind(s, <sockaddr *>&si_me, sizeof(si_me)) == -1):
  die("bind\n")
{% elif sig_type == 'parport' -%}
# make sure parport is writeable
if (portio.ioperm(0x{{in_signal['args']['addr']}}, 1, 1)):
  die("io permission denied\n")
{% elif sig_type == 'zmq' -%}
context = zmq_ctx_new()
if (not context):
  die("Could not create ZMQ context.\n")
dish = zmq_socket(context, ZMQ_DISH)
if (not dish):
  die("Could not create ZMQ socket.\n")
rc = zmq_bind(dish, "udp://{{in_signal['args']['addr']}}:{{in_signal['args']['port']}}")
assert (rc == 0)
{%- endif %}

make_realtime()

fflush(stdout)
kill(ppid, SIGUSR2) # TODO these kills should probably be semaphores
pause()
kill(ppid, SIGUSR2)

while(True):
{%- if sig_type == 'udp' %}
  recv_len = recvfrom(s, sigPtr, {{max_buf_size}}, 0, <sockaddr *> &si_other, &slen)
  num_packets += 1
{%- elif sig_type == 'parport' %}
  data = portio.inb(0x{{in_signal['args']['addr']}})
{%- elif sig_type == 'zmq' %}
  recv_len = zmq_recv(dish, buf, {{max_buf_size}}, 0)
  num_packets += 1
{%- endif %}
  if (parentSetup):
    continue
{%- if sig_type == 'udp' %}
  if (recv_len == -1 and errno != EINTR):
      die("NETWORK ERROR: recvfrom()")
  if (recv_len == -1):
    die("Read error.\n")
{%- endif %}
  # int outlen = {{parser}}(buf, recv_len, &outbuf)
  # parse_idx = 0
  # while (parse_idx < recv_len):
  #   in_sig[buf_offset] = buf[parse_idx]
  #   buf_offset += 1
  #   if (buf_offset >= out_sig_size):
  #     buf_offset = 0
  #   parse_idx += 1
  pLocalSignalMem[2] = buf_offset
  # printf("source: %d\n", recv_len)
  # printf("%s\n", buf)